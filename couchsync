#! /bin/bash
#
# Usage: couchsync dbdir
#

#
# Constants
#

# Local database
couchurl=http://localhost:5984

# Name of the docker container running the database
dbdockername=steenwerck-replicate

# Name of the docker image containing couchdb
dockerimage=rfc1149/pointage100km

# Path of the database files in containers created by $dockerimage
dockerdbdir=/usr/local/var/lib/couchdb

# Command to pass to the docker image to start only couchdb
dockercommand=couchdb

#
# Helper functions
#

# Print program usage
usage() {
  cat >&2 <<EOF
Usage: couchsync --init <usbkeypath>    Initialize a new USB key
       couchsync --watch                Check for insertion of USB keys
EOF
  exit 1
}

# Send a request. Parameters: <method> <URI> <extra command line arguments>
request() {
  curl -s -S -X "$@"
}

# Replicate full database to another one (without filtering). Used for backups.
backup_replicate() {
  request POST $1/_replicate \
    --data-binary "{\"source\":\"$2\",\"target\":\"$3\"}" \
    -H "Content-Type: application/json" > /dev/null
}

# Replicate from a database to another one. Args: <couch uri> <source> <target>
replicate() {
  request POST $1/_replicate \
    --data-binary "{\"source\":\"$2\",\"target\":\"$3\",\"filter\":\"common/to-replicate\"}" \
    -H "Content-Type: application/json" > /dev/null
}

# Compact a database. Arg: <db uri>
compact() {
  request POST $1/_compact -H "Content-Type: application/json" > /dev/null
}

# Wait for writes to be done. Arg: <db uri>
ensure_full_commit() {
  request POST $1/_ensure_full_commit -H "Content-Type: application/json" > /dev/null
}

# Send a message
message() {
  echo $1
  request POST $couchurl/steenwerck100km/_design/bib_input/_update/force-update/status \
    --data-urlencode "json={\"type\":\"status\",\"scope\":\"local\",\"message\":\"$1\"}" \
    -H "Content-Type: application/x-www-form-urlencoded" > /dev/null
}

step() {
  message "Ne pas enlever la clé USB - $1"
}

getdbkey() {
  echo $(request GET $couchurl/steenwerck100km/_design/common/_show/couchsync/couchsync)
}

#
# Initialization
#
initialize() {
  set -e
  usbkeydir="$1"
  if [ -e "$usbkeydir"/steenwerck -o -e "$usbkeydir"/databases ]; then
    echo "Please remove files 'steenwerck' and 'databases' in $usbkeydir first" >&2
    exit 1
  fi
  echo 'Creating authorization access file'
  getdbkey > "$usbkeydir"/steenwerck
  echo 'Creating directory for storing backup databases'
  mkdir "$usbkeydir"/databases
  chmod 777 "$usbkeydir"/databases
  echo 'Performing the initial backup'
  backup "$usbkeydir" true
  message 'La clé est prête'
  sleep 3
  message ""
}

#
# Backup. Args: <usb key directory> true/false (true if the database must be first created)
#
backup() {
  usbkeydir="$1"
  initial=$2
  # Start a new database linked to the steenwerck-replicate one under
  # the alias "pointage100km" (which will be installed in /etc/hosts) of
  # the newly started docker.
  step 'Démarrage de la base de sauvegarde'
  container=$(docker run -d -v "$usbkeydir/databases":"$dockerdbdir" \
		     --link $dbdockername:pointage100km -P $dockerimage $dockercommand)

  # Commpute the base URL to address the backup database
  backupcouchuri=http://$(docker port $container 5984 | sed -e 's/^0.0.0.0:/localhost:/')

  # Choose the backup file database name on the key to prevent accidents.
  syncdb=$(cat "$usbkeydir"/steenwerck | cut -c 1-16 | tr 'A-Z' 'a-z')

  # Choose a unique name for a backup database (before the synchronization).
  backupdb=backup-$$-$(date +%s)

  # Name of the main database as seen by the container
  maindbport=$(docker exec $container sh -c 'echo $POINTAGE100KM_PORT_5984_TCP_PORT')
  maindburi=http://pointage100km:$maindbport/steenwerck100km

  sleep 5
  if $initial; then
    # Create the sync DB and replicate it as a backup
    step 'réplication initiale'
    request PUT $backupcouchuri/$syncdb > /dev/null
    backup_replicate $backupcouchuri $maindburi $syncdb
  else
    # Create the backup DB and synchronize the main db to it
    step 'sauvegarde de sécurité préalable'
    request PUT $backupcouchuri/$backupdb > /dev/null
    backup_replicate $backupcouchuri $maindburi $backupdb
    compact $backupcouchuri/$backupdb
    ensure_full_commit $backupcouchuri/$backupdb
  fi

  # Synchronize the main DB with the sync one
  step 'synchronisation 1/2'
  replicate $backupcouchuri $maindburi $syncdb
  step 'synchronisation 2/2'
  replicate $backupcouchuri $syncdb $maindburi
  step 'compaction de la sauvegarde'
  compact $backupcouchuri/$syncdb

  # Wait until the replicate is flushed to disk by asking CouchDB to sync.
  step 'écriture sur disque'
  ensure_full_commit $backupcouchuri/$syncdb

  # Stop the database
  step 'arrêt de la base de sauvegarde'
  docker stop $container > /dev/null
  docker rm $container > /dev/null
}

#
# Watch
#
watch() {
  while true; do

    # Wait until a USB key appears, mounted under /media with a steenwerck file.
    steenwerck_file=""
    while [ "$steenwerck_file" = "" ]
    do
      sleep 1
      steenwerck_file=$(find /media/ -maxdepth 3 -type f -name steenwerck -print -quit 2> /dev/null)
    done

    # Go into the USB key to block a possible umount.
    usbkeydir=$(dirname $steenwerck_file)

    # Check the credentials on the key against the ones in the database
    step "Vérification de la validité de la clé USB"
    dbkey="$(getdbkey)"
    if [ x"$dbkey" = x"$(cat $usbkeydir/steenwerck)" ]; then
      backup "$usbkeydir" false
      endmsg="La clé USB peut être retirée"
    else
      endmsg="Authentification invalide - retirer la clé USB"
    fi

    # Umount USB key.
    umount "$usbkeydir"
    message "$endmsg"
    sleep 3
    message ""

  done
}

#
# Main program
#
if [ x"$1" = x--init -a -n "$2" -a $# = 2 ]; then
  initialize "$2"
  exit 0
fi

if [ x"$1" = x--watch -a $# = 1 ]; then
  watch
  exit 0
fi

usage
